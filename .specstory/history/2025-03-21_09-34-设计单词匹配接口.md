<!-- Generated by SpecStory -->

# 设计单词匹配接口 (2025-03-21 17:34:06)

_**User**_

期望的功能是，接收一片文章中所有的单词清单，用于跟数据库已认识的单词作匹配，返回不认识的单词清单，和认识的单词数量，请合理的设计该接口

---

_**Assistant**_

# 设计单词匹配接口

我将为您设计一个接口，用于接收文章中的单词清单，与数据库中已知的单词进行匹配，并返回不认识的单词清单和已认识的单词数量。

让我们在现有的 word.ts 文件中添加这个新接口：

```typescript:apps/an-monkey-worker/src/routers/word.ts
import type { Context, Hono } from 'hono'
import { usePrismaClient } from '../../prisma/utils/prismaClient'

export default (app: Hono, workspace: string) => {
  app.get(`${workspace}/`, async (c: Context) => {
    const { prismaClient } = await usePrismaClient(c)
    const words = await prismaClient.word.findMany()
    console.log('word', words)
    return c.json(words)
  })

  app.post(`${workspace}/`, async (c: Context) => {
    try {
      const { prismaClient } = await usePrismaClient(c)
      const body = await c.req.json()
      const data = Array.isArray(body) ? body : [body]

      const words = await prismaClient.word.createMany({
        data,
      })
      return c.json(words)
    } catch (error) {
      console.error('创建单词失败:', error)
      return c.json({ error: '创建单词失败' }, 500)
    }
  })

  // 新增接口：匹配文章中的单词
  app.post(`${workspace}/match`, async (c: Context) => {
    try {
      const { prismaClient } = await usePrismaClient(c)
      const body = await c.req.json()
      
      // 验证请求体中是否包含单词列表
      if (!body.words || !Array.isArray(body.words)) {
        return c.json({ error: '请求格式错误，需要提供单词列表' }, 400)
      }
      
      // 获取文章中的所有单词（假设已经处理为小写形式）
      const articleWords = body.words.map((word: string) => word.toLowerCase())
      
      // 从数据库获取所有已知单词
      const knownWords = await prismaClient.word.findMany({
        select: { word: true }
      })
      
      // 将已知单词转换为Set以便快速查找
      const knownWordsSet = new Set(knownWords.map(item => item.word.toLowerCase()))
      
      // 找出未知单词
      const unknownWords = articleWords.filter(word => !knownWordsSet.has(word))
      
      // 去重未知单词
      const uniqueUnknownWords = [...new Set(unknownWords)]
      
      // 计算已知单词数量
      const knownWordsCount = articleWords.length - unknownWords.length
      
      return c.json({
        knownWordsCount,
        totalWordsCount: articleWords.length,
        uniqueWordsCount: [...new Set(articleWords)].length,
        unknownWords: uniqueUnknownWords
      })
    } catch (error) {
      console.error('匹配单词失败:', error)
      return c.json({ error: '匹配单词失败' }, 500)
    }
  })
}
```

## 接口说明

我添加了一个新的 POST 接口 `/match`，它的功能如下：

1. 接收一个包含 `words` 数组的 JSON 请求体，这个数组包含文章中的所有单词
2. 从数据库获取所有已知单词
3. 将文章中的单词与已知单词进行匹配
4. 返回以下信息：
   - `knownWordsCount`: 已知单词的数量
   - `totalWordsCount`: 文章中单词的总数
   - `uniqueWordsCount`: 文章中不重复单词的数量
   - `unknownWords`: 未知单词列表（已去重）

## 使用示例

请求示例：
```json
{
  "words": ["hello", "world", "this", "is", "a", "test", "hello", "world"]
}
```

响应示例：
```json
{
  "knownWordsCount": 5,
  "totalWordsCount": 8,
  "uniqueWordsCount": 6,
  "unknownWords": ["test"]
}
```

这个设计考虑了以下几点：
1. 单词匹配不区分大小写
2. 返回未知单词时进行了去重，避免重复
3. 提供了文章中单词的总数和不重复单词的数量，便于统计分析
4. 包含了错误处理和输入验证

---

_**User**_

很好，如果数据库单词数据庞大以及接收的单词数量庞大时是否有问题？可以如何优化

---

_**Assistant**_

# 优化大数据量下的单词匹配接口

您提出了一个很好的问题。当数据库中的单词数量庞大或接收的文章单词数量很大时，当前实现可能会遇到性能问题。以下是几种优化方案：

```typescript:apps/an-monkey-worker/src/routers/word.ts
// ...existing code...

  // 优化后的匹配文章单词接口
  app.post(`${workspace}/match`, async (c: Context) => {
    try {
      const { prismaClient } = await usePrismaClient(c)
      const body = await c.req.json()
      
      // 验证请求体中是否包含单词列表
      if (!body.words || !Array.isArray(body.words)) {
        return c.json({ error: '请求格式错误，需要提供单词列表' }, 400)
      }
      
      // 获取文章中的所有单词并转为小写
      const articleWords = body.words.map((word: string) => word.toLowerCase())
      
      // 文章单词去重，减少数据库查询负担
      const uniqueArticleWords = [...new Set(articleWords)]
      
      // 使用 IN 查询，只查询文章中出现的单词
      // 这比获取所有单词更高效
      const knownWords = await prismaClient.word.findMany({
        where: {
          word: {
            in: uniqueArticleWords.map(w => w.toLowerCase()),
            mode: 'insensitive' // 不区分大小写
          }
        },
        select: { word: true }
      })
      
      // 将已知单词转换为Set以便快速查找
      const knownWordsSet = new Set(knownWords.map(item => item.word.toLowerCase()))
      
      // 找出未知单词（从去重后的单词列表中查找）
      const uniqueUnknownWords = uniqueArticleWords.filter(word => !knownWordsSet.has(word))
      
      // 计算已知单词数量（需要在原始列表中计算）
      let knownWordsCount = 0
      for (const word of articleWords) {
        if (knownWordsSet.has(word)) {
          knownWordsCount++
        }
      }
      
      return c.json({
        knownWordsCount,
        totalWordsCount: articleWords.length,
        uniqueWordsCount: uniqueArticleWords.length,
        unknownWords: uniqueUnknownWords
      })
    } catch (error) {
      console.error('匹配单词失败:', error)
      return c.json({ error: '匹配单词失败' }, 500)
    }
  })
// ...existing code...
```

## 优化说明

1. **减少数据库查询量**：
   - 不再获取数据库中的所有单词，而是只查询文章中出现的单词
   - 使用 `IN` 查询和 `insensitive` 模式进行不区分大小写的查询

2. **减少内存使用**：
   - 先对文章单词进行去重，再进行数据库查询，减少查询的数据量
   - 只在内存中保留必要的数据

3. **优化算法**：
   - 直接从数据库查询结果中构建已知单词集合
   - 从去重后的单词列表中筛选未知单词，减少过滤操作的次数

## 进一步优化建议

如果数据量仍然很大，可以考虑以下额外优化：

1. **分批处理**：
   - 如果文章单词数量极大，可以考虑分批查询数据库
   - 每批处理一部分单词，然后合并结果

2. **缓存机制**：
   - 为常见单词建立缓存，减少数据库查询
   - 可以使用 Redis 等缓存服务

3. **数据库索引**：
   - 确保 `word` 字段有适当的索引，加速查询

4. **异步处理**：
   - 对于特别大的文章，可以考虑异步处理模式
   - 先返回一个任务ID，然后通过另一个接口获取处理结果

5. **数据库优化**：
   - 如果单词表非常大，考虑使用全文索引或专门的搜索引擎
   - 可以考虑将单词表分片或使用更适合大规模文本处理的数据库结构

这些优化可以根据实际的性能测试结果和系统负载情况逐步实施。

---

_**User**_

在现有的filterWords之后再调用新增的数据库匹配接口，二次过滤

---

_**Assistant**_

# 整合数据库匹配接口到前端应用

我将修改前端应用，在现有的 `filterWords` 之后调用新增的数据库匹配接口，进行二次过滤。首先需要在 API 文件中添加新的函数，然后修改应用逻辑。

```typescript:apps/getEnWords/src/api.ts
// 添加新的匹配单词接口函数
export async function matchWords(words: string[]) {
  try {
    const response = await fetch('/api/word/match', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ words }),
    });
    
    if (!response.ok) {
      throw new Error(`匹配单词失败: ${response.statusText}`);
    }
    
    return await response.json();
  } catch (error) {
    console.error('匹配单词失败:', error);
    throw error;
  }
}

// ... existing code ...
```

现在让我们修改 App 组件，整合数据库匹配功能：

```typescript:apps/getEnWords/src/app.tsx
import { useToast } from "@an-monkey-tool/ui/ToastProvider";
import { useEffect, useState } from "preact/hooks";
import { matchWords, uploadWord } from "./api";
import { extractWordsFromElement, filterWords } from "./utils";

export function App() {
  const { showToast } = useToast();
  const [isopen, setIsopen] = useState(false);
  const [words, setWords] = useState<[string, number][]>([]);
  const [totalWords, setTotalWords] = useState(0);
  const [filteredWords, setFilteredWords] = useState(0);
  const [knownWordsCount, setKnownWordsCount] = useState(0);

  const getWords = async () => {
    try {
      // 从页面提取单词
      const extractedWords = extractWordsFromElement("");
      setTotalWords(extractedWords.length);
      
      // 第一次过滤（本地过滤）
      const afterLocalFiltered = await filterWords(extractedWords);
      const localFilteredCount = extractedWords.length - afterLocalFiltered.length;
      
      // 第二次过滤（数据库匹配）
      const wordsForMatching = afterLocalFiltered.map(([word]) => word);
      const matchResult = await matchWords(wordsForMatching);
      
      // 更新统计信息
      setKnownWordsCount(matchResult.knownWordsCount);
      setFilteredWords(localFilteredCount + matchResult.knownWordsCount);
      
      // 只保留未知单词
      const unknownWordsSet = new Set(matchResult.unknownWords);
      const finalWordList = afterLocalFiltered.filter(([word]) => 
        unknownWordsSet.has(word.toLowerCase())
      );
      
      setWords(finalWordList);
      showToast("🎉 单词获取成功");
    } catch (error) {
      console.error("获取单词失败:", error);
      showToast("❌ 获取单词失败");
    }
  };

  // ... existing code ...

  return (
    <div className="drawer drawer-end" style={{ zIndex: 9999 }}>
      {/* ... existing code ... */}
      <div className="drawer-side">
        <label
          htmlFor="my-drawer"
          aria-label="close sidebar"
          className="drawer-overlay"
        />
        <ul className="menu bg-base-200 text-base-content min-h-full w-4/5 p-4">
          <li>
            <button className="btn btn-primary" onClick={getWords}>
              获取单词
            </button>
          </li>
          {words.length > 0 && (
            <li className="mt-4">
              <div className="stats shadow w-full">
                <div className="stat">
                  <div className="stat-title">单词数</div>
                  <div className="stat-value">
                    {words.length}/{totalWords}
                  </div>
                </div>
                <div className="stat">
                  <div className="stat-title">已认识</div>
                  <div className="stat-value">{filteredWords}</div>
                  <div className="stat-desc">本地: {filteredWords - knownWordsCount} | 数据库: {knownWordsCount}</div>
                </div>
                <div className="stat">
                  <button
                    className="btn btn-primary btn-sm"
                    onClick={exportWords}
                  >
                    导出单词
                  </button>
                </div>
              </div>
              {/* ... existing table code ... */}
            </li>
          )}
        </ul>
      </div>
    </div>
  );
}
```

## 修改说明

1. **API 扩展**：
   - 添加了 `matchWords` 函数，用于调用后端的 `/match` 接口
   - 该函数接收单词数组，返回匹配结果

2. **单词处理流程**：
   - 首先使用现有的 `extractWordsFromElement` 从页面提取单词
   - 然后使用现有的 `filterWords` 进行第一次过滤（本地过滤）
   - 接着调用新增的 `matchWords` 进行第二次过滤（数据库匹配）
   - 最后只保留未知单词显示在列表中

3. **统计信息**：
   - 添加了 `knownWordsCount` 状态，用于记录数据库匹配到的已知单词数量
   - 更新了统计显示，区分本地过滤和数据库匹配的单词数量
   - 总的已认识单词数 = 本地过滤数 + 数据库匹配数

这样，用户可以清楚地看到单词过滤的来源，同时获得更准确的单词列表。当用户点击"获取单词"按钮时，系统会自动进行两次过滤，只显示真正未知的单词。

---

